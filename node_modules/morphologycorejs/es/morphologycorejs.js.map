{"version":3,"file":"morphologycorejs.js","sources":["../src/Section.js","../src/Soma.js","../src/Morphology.js","../src/index.js"],"sourcesContent":["/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/*\nStandardized swc files (www.neuromorpho.org)\n0 - undefined\n1 - soma\n2 - axon\n3 - (basal) dendrite\n4 - apical dendrite\n5+ - custom\n*/\nconst TYPEVALUE_2_TYPENAME = {\n  0: 'undefined',\n  1: 'soma',\n  2: 'axon',\n  3: 'basal_dendrite',\n  4: 'apical_dendrite',\n  5: 'custom',\n}\n\nconst TYPENAME_2_TYPEVALUE = {\n  undefined: 0,\n  soma: 1,\n  axon: 2,\n  basal_dendrite: 3,\n  apical_dendrite: 4,\n  custom: 5,\n}\n\n\n/**\n * A section is a list of 3D points and some metadata. A section can have one parent\n * and multiple children when the dendrite or axone divide into mutliple dendrites\n * and axons.\n * A section instance can be built from scratch of it can be built using a raw object,\n * usually from a JSON description.\n */\nclass Section {\n  /**\n   * To construct a section, we need a reference to the morphology instance that\n   * 'hosts' them. This may seem a bit a bit counter intuitive to have a reference\n   * in that direction but it can be very convenient, when knowing a section, to\n   * know to which morphology it belongs (i.e. raycasting a section)\n   * @param {Morphology} morphology - the Morphology instance that host _this_ section\n   */\n  constructor(morphology = null) {\n    this._id = null\n    this._parent = null\n    this._children = []\n    this._typename = null\n    this._typevalue = null\n    this._points = null\n    this._radiuses = null\n    this._morphology = morphology\n  }\n\n\n  /**\n   * Defines the id of this seciton.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the id of _this_ section\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Define the typename, like in the SWC spec. Must be one of:\n   *  - \"undefined\"\n   *  - \"soma\" (even though this one should be used to build a Soma instance)\n   *  - \"axon\"\n   *  - \"basal_dendrite\"\n   *  - \"apical_dendrite\"\n   *  - \"custom\"\n   * Not that this method automaically sets the typevalue accordingly.\n   * For more info, go to http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n   * @param {String} tn - the typename\n   */\n  setTypename(tn) {\n    if (tn in TYPENAME_2_TYPEVALUE) {\n      this._typename = tn\n      this._typevalue = TYPENAME_2_TYPEVALUE[tn]\n    } else {\n      console.warn(`The typename must be one of ${Object.key(TYPENAME_2_TYPEVALUE).join(' ')}`)\n    }\n  }\n\n\n  /**\n   * Get the typename as a String\n   * @return {String}\n   */\n  getTypename() {\n    return this._typename\n  }\n\n\n  /**\n   * Defnies the typevalue, which is the integer that goes in pair with the type name.\n   * According to SWC spec. Must be one of:\n   * - 0, for undefined\n   * - 1, for soma (even though this one should be used to build a Soma instance)\n   * - 2, for axon\n   * - 3, for basal dendrite\n   * - 4, for apical dendrite\n   * - 5, for custom\n   * Note that defining the type value will automatically set the type name accordingly.\n   * @param {Number} tv - the type value\n   */\n  setTypeValue(tv) {\n    this._typevalue = tv\n  }\n\n\n  /**\n   * Get the type value\n   * @return {Number}\n   */\n  getTypevalue() {\n    return this._typevalue\n  }\n\n\n  /**\n   * Add a point to _this_ current section\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   * @param {Number} r - the radius at the point to add. (default: 1)\n   */\n  addPoint(x, y, z, r = 1) {\n    this._points.push([x, y, z])\n    this._radiuses.push(r)\n  }\n\n\n  /**\n   * Get all the points of _this_ section as an array\n   * @return {Array} each element are of form [x: Number, y: Number, y: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Get all the radiuses of the point in _this_ section\n   * @return {Array}\n   */\n  getRadiuses() {\n    return this._radiuses\n  }\n\n\n  /**\n   * Build a section using a raw section object.\n   * @param {Object} rawSection - usually comes from a JSON file\n   */\n  initWithRawSection(rawSection) {\n    this._id = rawSection.id\n\n    this._points = rawSection.points.map(p => p.position)\n    this._radiuses = rawSection.points.map(p => p.radius)\n\n    // in some cases, we have only the typename or the typevalue, in this case we perform  a lookup\n    if (rawSection.typename || rawSection.typevalue) {\n      this._typename = rawSection.typename || TYPEVALUE_2_TYPENAME[rawSection.typevalue]\n      this._typevalue = rawSection.typevalue || TYPENAME_2_TYPEVALUE[rawSection.typename]\n    }\n\n    return this._id\n  }\n\n\n  /**\n   * Define the parent section of _this_ section, as an object reference.\n   * The only verification perfomed by this method is that a section is not added\n   * as its own parent.\n   * @param {Section} section - the section that is the parent of this one\n   * @return {Boolean} true if parent was successfully defined, false if not.\n   */\n  setParent(section) {\n    if (section && section.getId() !== this._id) {\n      this._parent = section\n      return true\n    }\n\n    console.warn('A section cannot be the parent of itself.')\n    return false\n  }\n\n\n  /**\n   * Get the parent section of _this_ section\n   * @return {Section} the parent\n   */\n  getParent() {\n    return this._parent\n  }\n\n\n  /**\n   * Make a given section the child of _this_ one.\n   * Two verifications are perfomed before: ids must be diferent so that we are\n   * not allowing a section to be the child of itself, and that _this_ section\n   * does not already have the given section as a children (=> avoid doublons)\n   * @param {Section} section - The section to add as a child\n   * @return {Boolean} true if successfully added (of if already has the given child),\n   * false if the candidate cannot be a child\n   */\n  addChild(section) {\n    if (section.getId() !== this._id) {\n      if (this.hasChild(section)) {\n        console.warn('The given section is already one of the child to this one.')\n      } else {\n        this._children.push(section)\n      }\n      return true\n    }\n    console.warn('A section cannot be the child of itself.')\n    return false\n  }\n\n\n  /**\n   * Checks if a given section is already one of the children of _this_ section\n   * @param {Section} section - a section to test\n   * @return {Boolean} true if the given section is already a child of _this_ section, false if not.\n   */\n  hasChild(section) {\n    if (!this._children) return false\n\n    const candidateId = section.getId()\n\n    for (let i = 0; i < this._children.length; i += 1) {\n      if (this._children[i].getId() === candidateId) return true\n    }\n    return false\n  }\n\n\n  /**\n   * Get the size of _this_ section\n   * @return {Number}\n   */\n  getSize() {\n    let sum = 0\n    for (let i = 0; i < this._points.length - 1; i += 1) {\n      const p1 = this._points[i]\n      const p2 = this._points[i + 1]\n      const dx = p1[0] - p2[0]\n      const dy = p1[1] - p2[1]\n      const dz = p1[2] - p2[2]\n      sum += Math.sqrt(dx * dx + dy * dy + dz * dz)\n    }\n\n    return sum\n  }\n\n\n  /**\n   * Get the morphology object that contains this section\n   * @return {Morphology}\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n\n  /**\n   * Get all the children as an Array\n   * @return {Array}\n   */\n  getChildren() {\n    return this._children\n  }\n}\n\nexport default Section\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/**\n * The soma is the cell body of a neurone and thus is sort of a simplified version\n * of a Section, in term of datastructure.\n * A soma can be made of a single point (then it's just a center point) or of several,\n * then it's a more accurate description of a soma. When described with several points,\n * the representation is usually as a 2D polygon (even though it's in a 3D space)\n */\nclass Soma {\n  constructor() {\n    this._id = null\n    this._typename = 'soma'\n    this._typevalue = 1\n    this._points = []\n    this._radius = null\n  }\n\n  /**\n   * Defines the id of this soma.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the id of _this_ soma\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Add a point to the soma description\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   */\n  addPoint(x, y, z) {\n    this._points.push([x, y, z])\n  }\n\n\n  /**\n   * Get all the points of the soma\n   * @return {Array} each element of the array if of form [x: Number, y: Number, z: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Define the radius of the soma\n   * @param {Number} r - the radius\n   */\n  setRadius(r) {\n    this._radius = r\n  }\n\n\n  /**\n   * Get the radius of the soma.\n   * @return {Number}\n   */\n  getRadius() {\n    return this._radius\n  }\n\n\n  /**\n   * Return the center of the soma.\n   * If the soma is made of a single point and a radius, this method returns the\n   * single point. If the soma is made of several points, this method returns the\n   * average.\n   * @return {Array|null} coordinate of the center as [x: Number, y: Number, z: Number]\n   */\n  getCenter() {\n    const nbPoints = this._points.length\n\n    if (nbPoints === 1) {\n      return this._points[0].slice()\n    }\n\n    if (nbPoints > 1) {\n      const average = [0, 0, 0]\n      for (let i = 0; i < nbPoints; i += 1) {\n        average[0] += this._points[i][0]\n        average[1] += this._points[i][1]\n        average[2] += this._points[i][2]\n      }\n      average[0] /= nbPoints\n      average[1] /= nbPoints\n      average[2] /= nbPoints\n      return average\n    }\n    return null\n  }\n\n\n  /**\n   * Build a soma using a raw soma object.\n   * @param {Object} rawSoma - usually comes from a JSON file\n   */\n  initWithRawSection(rawSoma) {\n    if (!rawSoma) {\n      console.warn('Cannot init the Soma instance, no soma data provided in raw morphology.')\n      return null\n    }\n\n    this._id = rawSoma.id\n    this._points = rawSoma.points.map(p => p.position)\n    this._radius = rawSoma.radius\n\n    return this._id\n  }\n}\n\n\nexport default Soma\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\nimport Section from './Section'\nimport Soma from './Soma'\n\n\n/**\n * A morphology is the data representation of a neurone's anatomy. It is composed\n * of one soma (cell body) and sections. Sections can be axons, dendrites, etc.\n * A Morphology instance can be built from scratch (though it can be a bit tedious)\n * but will generally be built using a JSON description.\n */\nclass Morphology {\n  constructor() {\n    this._id = null\n    this._sections = {}\n    this._soma = null\n\n    // these are catgories of sections that we may need. Look at `getOrphanSections`\n    // and `_findSpecialSection`\n    this._specialSections = {}\n  }\n\n\n  /**\n   * Set the ID of _this_ morphology\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the ID of _this_ morphology\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Build a morphology from a raw dataset, that usually comes from a JSON file.\n   * Note that some files do not provide any data about the soma. In this case, the Soma\n   * instance remains `null`\n   * @param {Object} rawMorphology - a flat tree description of a morphology\n   */\n  buildFromRawMorphology(rawMorphology) {\n    // Sometimes, we have no data about the soma\n    if (rawMorphology.soma) {\n      this._soma = new Soma()\n      this._soma.initWithRawSection(rawMorphology.soma)\n    }\n\n    // Build the Section instances.\n    // This first step does not define parents nor children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const s = new Section(this)\n      const sId = s.initWithRawSection(rawMorphology.sections[i])\n      this._sections[sId] = s\n    }\n\n    // Now we define parent and children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const currentRawSection = rawMorphology.sections[i]\n      const currentSection = this._sections[currentRawSection.id]\n\n      // adding a parent if there is one\n      // can be 0 but cannot be null (in JS, 0 and null are diff)\n      if (currentRawSection.parent !== null) {\n        const parent = this._sections[currentRawSection.parent]\n        currentSection.setParent(parent)\n      }\n\n      const children = currentRawSection.children.map(c => this._sections[c])\n      for (let c = 0; c < children.length; c += 1) {\n        currentSection.addChild(children[c])\n      }\n    }\n  }\n\n\n  /**\n   * Retrieve the total number of section in this morphology\n   * @return {Number}\n   */\n  getNumberOfSections() {\n    return Object.keys(this._sections)\n  }\n\n\n  /**\n   * Get a section, given its id\n   * @param {String|Number} id - the id of a section\n   * @return {Section|null} the requested section or null if the id is invalid\n   */\n  getSection(id) {\n    if (id in this._sections) {\n      return this._sections[id]\n    }\n    return null\n  }\n\n\n  /**\n   * Get all the sections of _this_ morphology as an array, because sometimes it's\n   * more convenient for iterating.\n   * @return {Array} array of Section instances\n   */\n  getArrayOfSections() {\n    return Object.values(this._sections)\n  }\n\n\n  /**\n   * Get the soma Object\n   * @return {Soma}\n   */\n  getSoma() {\n    return this._soma\n  }\n\n\n  /**\n   * Get all the section with no parent (_parent = null)\n   * Those are directly tied to the soma\n   * @param {Boolean} force - if true, the fetching among the sections will be done again\n   * @return {Array} array of Sections\n   */\n  getOrphanSections(force = false) {\n    const speciality = 'orphans'\n\n    // extract, if not done before\n    this._findSpecialSection(\n      'orphans',\n      s => !s.getParent(),\n      force,\n    )\n\n    return this._specialSections[speciality]\n  }\n\n\n  /**\n   * @private\n   * Helper function to build a subset of Sections based on the selections perfomed by `selector`\n   * @param {String} specialityName - name of the spaciality\n   * @param {Function} selector - function that takes a Section and returns a boolean.\n   * if true is return, a section will be selected\n   * @param {Boolean} force - if true: rebuild the list, if false:\n   * just return the list previously build\n   */\n  _findSpecialSection(specialityName, selector, force = false) {\n    if (!(specialityName in this._specialSections)) {\n      this._specialSections[specialityName] = null\n    }\n\n    if (force || !this._specialSections[specialityName]) {\n      this._specialSections[specialityName] = []\n      const allSections = Object.values(this._sections)\n      for (let i = 0; i < allSections.length; i += 1) {\n        if (selector(allSections[i])) {\n          this._specialSections[specialityName].push(allSections[i])\n        }\n      }\n    }\n    return this._specialSections[specialityName]\n  }\n}\n\nexport default Morphology\n","import Morphology from './Morphology'\n\nexport default ({\n  Morphology,\n})\n\n\n// export default Morphology\n"],"names":[],"mappings":"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"}