{"version":3,"file":"morphologycorejs.js","sources":["../src/Section.js","../src/Soma.js","../src/Morphology.js","../src/index.js"],"sourcesContent":["/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/*\nStandardized swc files (www.neuromorpho.org)\n0 - undefined\n1 - soma\n2 - axon\n3 - (basal) dendrite\n4 - apical dendrite\n5+ - custom\n*/\nconst TYPEVALUE_2_TYPENAME = {\n  0: 'undefined',\n  1: 'soma',\n  2: 'axon',\n  3: 'basal_dendrite',\n  4: 'apical_dendrite',\n  5: 'custom',\n}\n\nconst TYPENAME_2_TYPEVALUE = {\n  undefined: 0,\n  soma: 1,\n  axon: 2,\n  basal_dendrite: 3,\n  apical_dendrite: 4,\n  custom: 5,\n}\n\n\n/**\n * A section is a list of 3D points and some metadata. A section can have one parent\n * and multiple children when the dendrite or axone divide into mutliple dendrites\n * and axons.\n * A section instance can be built from scratch of it can be built using a raw object,\n * usually from a JSON description.\n */\nclass Section {\n  /**\n   * To construct a section, we need a reference to the morphology instance that\n   * 'hosts' them. This may seem a bit a bit counter intuitive to have a reference\n   * in that direction but it can be very convenient, when knowing a section, to\n   * know to which morphology it belongs (i.e. raycasting a section)\n   * @param {Morphology} morphology - the Morphology instance that host _this_ section\n   */\n  constructor(morphology = null) {\n    this._id = null\n    this._parent = null\n    this._children = []\n    this._typename = null\n    this._typevalue = null\n    this._points = null\n    this._radiuses = null\n    this._morphology = morphology\n  }\n\n\n  /**\n   * Defines the id of this seciton.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the id of _this_ section\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Define the typename, like in the SWC spec. Must be one of:\n   *  - \"undefined\"\n   *  - \"soma\" (even though this one should be used to build a Soma instance)\n   *  - \"axon\"\n   *  - \"basal_dendrite\"\n   *  - \"apical_dendrite\"\n   *  - \"custom\"\n   * Not that this method automaically sets the typevalue accordingly.\n   * For more info, go to http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n   * @param {String} tn - the typename\n   */\n  setTypename(tn) {\n    if (tn in TYPENAME_2_TYPEVALUE) {\n      this._typename = tn\n      this._typevalue = TYPENAME_2_TYPEVALUE[tn]\n    } else {\n      console.warn(`The typename must be one of ${Object.key(TYPENAME_2_TYPEVALUE).join(' ')}`)\n    }\n  }\n\n\n  /**\n   * Get the typename as a String\n   * @return {String}\n   */\n  getTypename() {\n    return this._typename\n  }\n\n\n  /**\n   * Defnies the typevalue, which is the integer that goes in pair with the type name.\n   * According to SWC spec. Must be one of:\n   * - 0, for undefined\n   * - 1, for soma (even though this one should be used to build a Soma instance)\n   * - 2, for axon\n   * - 3, for basal dendrite\n   * - 4, for apical dendrite\n   * - 5, for custom\n   * Note that defining the type value will automatically set the type name accordingly.\n   * @param {Number} tv - the type value\n   */\n  setTypeValue(tv) {\n    this._typevalue = tv\n  }\n\n\n  /**\n   * Get the type value\n   * @return {Number}\n   */\n  getTypevalue() {\n    return this._typevalue\n  }\n\n\n  /**\n   * Add a point to _this_ current section\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   * @param {Number} r - the radius at the point to add. (default: 1)\n   */\n  addPoint(x, y, z, r = 1) {\n    this._points.push([x, y, z])\n    this._radiuses.push(r)\n  }\n\n\n  /**\n   * Get all the points of _this_ section as an array\n   * @return {Array} each element are of form [x: Number, y: Number, y: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Get all the radiuses of the point in _this_ section\n   * @return {Array}\n   */\n  getRadiuses() {\n    return this._radiuses\n  }\n\n\n  /**\n   * Build a section using a raw section object.\n   * @param {Object} rawSection - usually comes from a JSON file\n   */\n  initWithRawSection(rawSection) {\n    this._id = rawSection.id\n\n    this._points = rawSection.points.map(p => p.position)\n    this._radiuses = rawSection.points.map(p => p.radius)\n\n    // in some cases, we have only the typename or the typevalue, in this case we perform  a lookup\n    if (rawSection.typename || rawSection.typevalue) {\n      this._typename = rawSection.typename || TYPEVALUE_2_TYPENAME[rawSection.typevalue]\n      this._typevalue = rawSection.typevalue || TYPENAME_2_TYPEVALUE[rawSection.typename]\n    }\n\n    return this._id\n  }\n\n\n  /**\n   * Define the parent section of _this_ section, as an object reference.\n   * The only verification perfomed by this method is that a section is not added\n   * as its own parent.\n   * @param {Section} section - the section that is the parent of this one\n   * @return {Boolean} true if parent was successfully defined, false if not.\n   */\n  setParent(section) {\n    if (section && section.getId() !== this._id) {\n      this._parent = section\n      return true\n    }\n\n    console.warn('A section cannot be the parent of itself.')\n    return false\n  }\n\n\n  /**\n   * Get the parent section of _this_ section\n   * @return {Section} the parent\n   */\n  getParent() {\n    return this._parent\n  }\n\n\n  /**\n   * Make a given section the child of _this_ one.\n   * Two verifications are perfomed before: ids must be diferent so that we are\n   * not allowing a section to be the child of itself, and that _this_ section\n   * does not already have the given section as a children (=> avoid doublons)\n   * @param {Section} section - The section to add as a child\n   * @return {Boolean} true if successfully added (of if already has the given child),\n   * false if the candidate cannot be a child\n   */\n  addChild(section) {\n    if (section.getId() !== this._id) {\n      if (this.hasChild(section)) {\n        console.warn('The given section is already one of the child to this one.')\n      } else {\n        this._children.push(section)\n      }\n      return true\n    }\n    console.warn('A section cannot be the child of itself.')\n    return false\n  }\n\n\n  /**\n   * Checks if a given section is already one of the children of _this_ section\n   * @param {Section} section - a section to test\n   * @return {Boolean} true if the given section is already a child of _this_ section, false if not.\n   */\n  hasChild(section) {\n    if (!this._children) return false\n\n    const candidateId = section.getId()\n\n    for (let i = 0; i < this._children.length; i += 1) {\n      if (this._children[i].getId() === candidateId) return true\n    }\n    return false\n  }\n\n\n  /**\n   * Get the size of _this_ section\n   * @return {Number}\n   */\n  getSize() {\n    let sum = 0\n    for (let i = 0; i < this._points.length - 1; i += 1) {\n      const p1 = this._points[i]\n      const p2 = this._points[i + 1]\n      const dx = p1[0] - p2[0]\n      const dy = p1[1] - p2[1]\n      const dz = p1[2] - p2[2]\n      sum += Math.sqrt(dx * dx + dy * dy + dz * dz)\n    }\n\n    return sum\n  }\n\n\n  /**\n   * Get the morphology object that contains this section\n   * @return {Morphology}\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n\n  /**\n   * Get all the children as an Array\n   * @return {Array}\n   */\n  getChildren() {\n    return this._children\n  }\n}\n\nexport default Section\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/**\n * The soma is the cell body of a neurone and thus is sort of a simplified version\n * of a Section, in term of datastructure.\n * A soma can be made of a single point (then it's just a center point) or of several,\n * then it's a more accurate description of a soma. When described with several points,\n * the representation is usually as a 2D polygon (even though it's in a 3D space)\n */\nclass Soma {\n  constructor() {\n    this._id = null\n    this._typename = 'soma'\n    this._typevalue = 1\n    this._points = []\n    this._radius = null\n  }\n\n  /**\n   * Defines the id of this soma.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the id of _this_ soma\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Add a point to the soma description\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   */\n  addPoint(x, y, z) {\n    this._points.push([x, y, z])\n  }\n\n\n  /**\n   * Get all the points of the soma\n   * @return {Array} each element of the array if of form [x: Number, y: Number, z: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Define the radius of the soma\n   * @param {Number} r - the radius\n   */\n  setRadius(r) {\n    this._radius = r\n  }\n\n\n  /**\n   * Get the radius of the soma.\n   * @return {Number}\n   */\n  getRadius() {\n    return this._radius\n  }\n\n\n  /**\n   * Return the center of the soma.\n   * If the soma is made of a single point and a radius, this method returns the\n   * single point. If the soma is made of several points, this method returns the\n   * average.\n   * @return {Array|null} coordinate of the center as [x: Number, y: Number, z: Number]\n   */\n  getCenter() {\n    const nbPoints = this._points.length\n\n    if (nbPoints === 1) {\n      return this._points[0].slice()\n    }\n\n    if (nbPoints > 1) {\n      const average = [0, 0, 0]\n      for (let i = 0; i < nbPoints; i += 1) {\n        average[0] += this._points[i][0]\n        average[1] += this._points[i][1]\n        average[2] += this._points[i][2]\n      }\n      average[0] /= nbPoints\n      average[1] /= nbPoints\n      average[2] /= nbPoints\n      return average\n    }\n    return null\n  }\n\n\n  /**\n   * Build a soma using a raw soma object.\n   * @param {Object} rawSoma - usually comes from a JSON file\n   */\n  initWithRawSection(rawSoma) {\n    if (!rawSoma) {\n      console.warn('Cannot init the Soma instance, no soma data provided in raw morphology.')\n      return null\n    }\n\n    this._id = rawSoma.id\n    this._points = rawSoma.points.map(p => p.position)\n    this._radius = rawSoma.radius\n\n    return this._id\n  }\n}\n\n\nexport default Soma\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\nimport Section from './Section'\nimport Soma from './Soma'\n\n\n/**\n * A morphology is the data representation of a neurone's anatomy. It is composed\n * of one soma (cell body) and sections. Sections can be axons, dendrites, etc.\n * A Morphology instance can be built from scratch (though it can be a bit tedious)\n * but will generally be built using a JSON description.\n */\nclass Morphology {\n  constructor() {\n    this._id = null\n    this._sections = {}\n    this._soma = null\n\n    // these are catgories of sections that we may need. Look at `getOrphanSections`\n    // and `_findSpecialSection`\n    this._specialSections = {}\n  }\n\n\n  /**\n   * Set the ID of _this_ morphology\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id\n  }\n\n\n  /**\n   * Get the ID of _this_ morphology\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Build a morphology from a raw dataset, that usually comes from a JSON file.\n   * Note that some files do not provide any data about the soma. In this case, the Soma\n   * instance remains `null`\n   * @param {Object} rawMorphology - a flat tree description of a morphology\n   */\n  buildFromRawMorphology(rawMorphology) {\n    // Sometimes, we have no data about the soma\n    if (rawMorphology.soma) {\n      this._soma = new Soma()\n      this._soma.initWithRawSection(rawMorphology.soma)\n    }\n\n    // Build the Section instances.\n    // This first step does not define parents nor children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const s = new Section(this)\n      const sId = s.initWithRawSection(rawMorphology.sections[i])\n      this._sections[sId] = s\n    }\n\n    // Now we define parent and children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const currentRawSection = rawMorphology.sections[i]\n      const currentSection = this._sections[currentRawSection.id]\n\n      // adding a parent if there is one\n      // can be 0 but cannot be null (in JS, 0 and null are diff)\n      if (currentRawSection.parent !== null) {\n        const parent = this._sections[currentRawSection.parent]\n        currentSection.setParent(parent)\n      }\n\n      const children = currentRawSection.children.map(c => this._sections[c])\n      for (let c = 0; c < children.length; c += 1) {\n        currentSection.addChild(children[c])\n      }\n    }\n  }\n\n\n  /**\n   * Retrieve the total number of section in this morphology\n   * @return {Number}\n   */\n  getNumberOfSections() {\n    return Object.keys(this._sections)\n  }\n\n\n  /**\n   * Get a section, given its id\n   * @param {String|Number} id - the id of a section\n   * @return {Section|null} the requested section or null if the id is invalid\n   */\n  getSection(id) {\n    if (id in this._sections) {\n      return this._sections[id]\n    }\n    return null\n  }\n\n\n  /**\n   * Get all the sections of _this_ morphology as an array, because sometimes it's\n   * more convenient for iterating.\n   * @return {Array} array of Section instances\n   */\n  getArrayOfSections() {\n    return Object.values(this._sections)\n  }\n\n\n  /**\n   * Get the soma Object\n   * @return {Soma}\n   */\n  getSoma() {\n    return this._soma\n  }\n\n\n  /**\n   * Get all the section with no parent (_parent = null)\n   * Those are directly tied to the soma\n   * @param {Boolean} force - if true, the fetching among the sections will be done again\n   * @return {Array} array of Sections\n   */\n  getOrphanSections(force = false) {\n    const speciality = 'orphans'\n\n    // extract, if not done before\n    this._findSpecialSection(\n      'orphans',\n      s => !s.getParent(),\n      force,\n    )\n\n    return this._specialSections[speciality]\n  }\n\n\n  /**\n   * @private\n   * Helper function to build a subset of Sections based on the selections perfomed by `selector`\n   * @param {String} specialityName - name of the spaciality\n   * @param {Function} selector - function that takes a Section and returns a boolean.\n   * if true is return, a section will be selected\n   * @param {Boolean} force - if true: rebuild the list, if false:\n   * just return the list previously build\n   */\n  _findSpecialSection(specialityName, selector, force = false) {\n    if (!(specialityName in this._specialSections)) {\n      this._specialSections[specialityName] = null\n    }\n\n    if (force || !this._specialSections[specialityName]) {\n      this._specialSections[specialityName] = []\n      const allSections = Object.values(this._sections)\n      for (let i = 0; i < allSections.length; i += 1) {\n        if (selector(allSections[i])) {\n          this._specialSections[specialityName].push(allSections[i])\n        }\n      }\n    }\n    return this._specialSections[specialityName]\n  }\n}\n\nexport default Morphology\n","import Morphology from './Morphology'\n\nexport default ({\n  Morphology,\n})\n\n\n// export default Morphology\n"],"names":[],"mappings":"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"}