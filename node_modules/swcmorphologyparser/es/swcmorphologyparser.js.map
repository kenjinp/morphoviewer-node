{"version":3,"file":"swcmorphologyparser.js","sources":["../src/Constants.js","../src/TreeNode.js","../src/TreeNodeCollection.js","../src/SwcParser.js","../src/index.js"],"sourcesContent":["/*\n * Defines the SWC standard types as in http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n */\nconst SWC_TYPES = {\n  UNDEFINED: 0,\n  SOMA: 1,\n  AXON: 2,\n  BASAL_DENDRITE: 3,\n  APICAL_DENDRITE: 4,\n  CUSTOM: 5,\n}\n\nexport default ({\n  SWC_TYPES,\n})\n","import SWC_TYPES from './Constants'\n\n/**\n * A TreeNode instance represent a point from the SWC file. It has a 3D coordinate,\n * an ID, a type, a radius, a reference to a parent (which is also a TreeNode\n * instance) and a list of children (also TreeNode instances).\n *\n * **Ressources**\n * - [SWC Spec](http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html)\n */\nclass TreeNode {\n  /**\n   * @param {Number} id - the id of the point\n   * @param {Number} type - type of structure this point comes from (cf. SWC spec)\n   * @param {Number} x - x component of the 3D coordinates\n   * @param {Number} y - y component of the 3D coordinates\n   * @param {Number} z - z component of the 3D coordinates\n   * @param {Number} r - radius at this given point\n   */\n  constructor(id, type, x, y, z, r) {\n    this._id = id\n    this._type = type\n    this._position = [x, y, z]\n    this._radius = r\n\n    this._parent = null\n    this._children = []\n\n    this._hasSomaChildren = false\n  }\n\n  /**\n   * Get the ID of _this_ node\n   * @return {Number}\n   */\n  getId() {\n    return this._id\n  }\n\n  /**\n   * Get the type as a number (according to the SWC spec)\n   * @return {Number}\n   */\n  getType() {\n    return this._type\n  }\n\n  /**\n   * @return {Boolean} true if this node is a soma, false if not\n   */\n  isSoma() {\n    return (this._type === SWC_TYPES.SOMA)\n  }\n\n  /**\n   * Get teh radius of _this_ node\n   * @return {Number}\n   */\n  getRadius() {\n    return this._radius\n  }\n\n  /**\n   * Get the 3D coordinates of this node\n   */\n  getPosition() {\n    return this._position\n  }\n\n  /**\n   * Define the parent of _this_ node\n   * @param {TreeNode} parent - the parent node\n   */\n  setParent(pNode) {\n    this._parent = pNode\n    pNode._addChild(this)\n  }\n\n  /**\n   * Get the parent node of _this_ one\n   * @return {TreeNode}\n   */\n  getParent() {\n    return this._parent\n  }\n\n  /**\n   * @private\n   * Add a child to _this_ node\n   * @param {TreeNode} cNode - a node to add as a child of _this_\n   */\n  _addChild(cNode) {\n    if (!this.doesAlreadyHaveChild(cNode)) {\n      this._children.push(cNode)\n\n      this._hasSomaChildren = cNode.isSoma() || this._hasSomaChildren\n    }\n  }\n\n  /**\n   * Get all the chidren\n   * @return {Array} array of TreeNode instances\n   */\n  getChildren() {\n    return this._children\n  }\n\n  /**\n   * Get all the children that are not soma points.\n   * @return {Array} array of TreeNode instances\n   */\n  getNonSomaChildren() {\n    if (!this._hasSomaChildren) {\n      return this._children\n    }\n\n    const nonSomaChildren = []\n\n    for (let i = 0; i < this._children.length; i += 0) {\n      if (!this._children[i].isSoma()) {\n        nonSomaChildren.push(this._children[i])\n      }\n    }\n    return nonSomaChildren\n  }\n\n  /**\n   * Check is _this_ node already has the given child amond its list of children\n   * @param {TreeNode} cNode - some node to test, most likely a potential child\n   * @return {Boolean} true if this child is already present, false if not\n   */\n  doesAlreadyHaveChild(cNode) {\n    for (let i = 0; i < this._children.length; i += 1) {\n      if (this._children[i].getId() === cNode.getId()) { return true }\n    }\n    return false\n  }\n\n  /**\n   * Dive into the TreeNode connection by following the children. Builds a list\n   * all along. Stops when a node has no more children (end of branch) or when a\n   * node has two children or more because it means it's a forking point.\n   * What is returned in the end is an array that can be empty (if end of branch)\n   * or with two or more TreeNode instance being the forking direction\n   * @param {Array} nodeList - contains the previous TreeNode (parent, grand parents, etc.)\n   * this array is only pushed to, nothing is taken or read from it.\n   * @return {Array} of TreeNodes that are forking direction.\n   */\n  dive(nodeList) {\n    // adding the current node on the list\n    nodeList.push(this)\n\n    const children = this.getNonSomaChildren()\n\n    // this current node is in the middle of a sections, we go on...\n    if (children.length === 1) {\n      if (children[0].getType() === this._type) {\n        return children[0].dive(nodeList)\n      }\n      console.warn(`Non-soma node (id:${this._id} type:${this._type}) has a single child of different type (id:${children[0].getId()} type:${this.getType()})`)\n\n\n    // this is or a ending point (no children) or a forking point (2 children or more).\n    // In both case, this the end of a sections\n    } else {\n      return children\n    }\n\n    return []\n  }\n}\n\nexport default TreeNode\n","import morphologycorejs from 'morphologycorejs'\nimport TreeNode from './TreeNode'\nimport SWC_TYPES from './Constants'\n\n/**\n * A TreeNodeCollection instance builds all the TreeNode instances from the raw\n * points list from the SWC file. As a second step, it builds the parent/children\n * relations between the nodes and as a third step, define a list of sections.\n */\nclass TreeNodeCollection {\n  /**\n   * @param {Array} points - every points of the array is itself an Array of form:\n   * [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   */\n  constructor(points) {\n    this._nodes = {}\n    this._rawSoma = null\n    this._rawSections = null\n    this._rawMorphology = null\n    this._morphology = null\n    this._initCollection(points)\n    this._buildSections()\n    this._buildMorphologyObjects()\n  }\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology() {\n    return this._rawMorphology\n  }\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n  /**\n   * @private\n   * Makes the list of nodes\n   */\n  _initCollection(points) {\n    const somaNodes = []\n\n    for (let i = 0; i < points.length; i += 1) {\n      const aNode = new TreeNode(\n        points[i][0], // id\n        points[i][1], // type\n        points[i][2], // x\n        points[i][3], // y\n        points[i][4], // z\n        points[i][5], // radius\n      )\n\n      this._nodes[points[i][0]] = aNode\n\n      // The soma nodes: in addition to put them in the regular collection,\n      // we also put them in a small collection we keep on the side\n      if (points[i][1] === SWC_TYPES.SOMA) {\n        somaNodes.push(aNode)\n      }\n\n      // In the SWC, a node/point seems to be always described after its parent,\n      // so we can makes the parent/children links in the same loop\n      const parentId = points[i][6]\n\n      // the first point of the soma has no parent\n      if (parentId === -1) { continue }\n\n      const theParentNode = this._nodes[parentId]\n      aNode.setParent(theParentNode)\n    }\n\n    // build the soma if we have some soma points\n    if (somaNodes.length) {\n      this._rawSoma = {\n        id: 0, // just to have the same format as the NeuroM converter\n        type: 'soma',\n        // the radius are usually all the same, but just in case, we take the largest one\n        radius: Math.max(...somaNodes.map(n => n.getRadius())),\n        points: somaNodes.map(n => ({ position: n.getPosition() })),\n      }\n    }\n  }\n\n  /**\n   * @private\n   * Reconstruct all the section from the nodes, give them IDs and establish the\n   * parent/children relationship\n   */\n  _buildSections() {\n    let currentSectionId = 0\n    const sections = []\n\n    // find the first node that has non-soma children:\n    let firstValidNode = null\n    let firstValidChildren = []\n\n    const allNodeIds = Object.keys(this._nodes)\n    for (let i = 0; i < allNodeIds.length; i += 1) {\n      const nodeId = allNodeIds[i]\n      const childrenOfNode = this._nodes[nodeId].getNonSomaChildren()\n      if (childrenOfNode.length > 0) {\n        firstValidNode = this._nodes[nodeId]\n        firstValidChildren = childrenOfNode\n        break\n      }\n    }\n\n    if (!firstValidNode) {\n      console.warn('No valid section here')\n      return\n    }\n\n    const stack = []\n\n    // add all the children of the firstValidNode into the stack\n    for (let i = 0; i < firstValidChildren.length; i += 1) {\n      stack.push({\n        node: firstValidChildren[i],\n        parentSectionId: null,\n      })\n    }\n\n    function buildRawSection(startingNode, parentSectionId) {\n      // the nodeList is the list of node for the section we are building.\n      // Let's say it's just a simpler version of the future section object\n      const nodeList = []\n\n      // for each starting node, we actually have to start by adding its parent\n      // to start the branch from its very basis\n      if (startingNode.getParent()) {\n        nodeList.push(startingNode.getParent())\n      }\n\n      // nodeList.push(startingNode)\n      // let nextNodes = startingNode.getNonSomaChildren()[0].dive(nodeList)\n\n      const nextNodes = startingNode.dive(nodeList)\n\n      const points = nodeList.map(n => ({\n        position: n.getPosition(),\n        radius: n.getRadius(),\n      }))\n\n      // if the first point is a soma point, we dont keep the first radius\n      // because it's the radius of the soma\n      if (parentSectionId === null && points.length) {\n        points[0].radius = 0\n      }\n\n      // now nodeList is full of nodes\n      const section = {\n        typevalue: startingNode.getType(),\n        typename: null, //\n        points,\n        id: currentSectionId,\n        children: [],\n        parent: parentSectionId,\n      }\n\n      // adding this section as a child of its parent\n      // (this is made possible because the parents are always defined before their children)\n      if (parentSectionId) {\n        sections[parentSectionId].children.push(currentSectionId)\n      }\n\n      // adding the next nodes as new section starting points\n      for (let i = 0; i < nextNodes.length; i += 1) {\n        stack.push({\n          node: nextNodes[i],\n          parentSectionId: currentSectionId,\n        })\n      }\n\n      currentSectionId += 1\n      return section\n    }\n\n    // popping the stack\n    while (stack.length) {\n      const stackElem = stack.pop()\n      const section = buildRawSection(stackElem.node, stackElem.parentSectionId)\n      sections.push(section)\n      sections[section.id] = section\n    }\n\n    if (sections.length) {\n      this._rawSections = sections\n    }\n  }\n\n  /**\n   * @private\n   * Performs some verification and then assemble the raw morphology\n   */\n  _buildMorphologyObjects() {\n    // it's ok to not have any section\n    if (!this._rawSections) {\n      console.warn('This morphology has no section to export')\n    }\n\n    // it's ok to not have a soma\n    if (!this._rawSoma) {\n      console.warn('This morphology has no soma to show')\n    }\n\n    // but it's not ok to have nothing at all\n    if (!this._rawSections && !this._rawSoma) {\n      console.warn('No valid morphology data.')\n      return\n    }\n\n    this._rawMorphology = {\n      soma: this._rawSoma,\n      sections: this._rawSections,\n    }\n\n    this._morphology = new morphologycorejs.Morphology()\n    this._morphology.buildFromRawMorphology(this._rawMorphology)\n  }\n}\n\nexport default TreeNodeCollection\n","import TreeNodeCollection from './TreeNodeCollection'\n\n\n/**\n * An instance of SwcParser is made to parse SWC files with\n * [the given specification](http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html).\n * The data output by this parser is a Javascript object representing a the tree\n * structure of the morphology. Each node of the tree is a section that contain a reference\n * to its parent section and references to its children sections.\n * The tree is given flat, meaning all the sections are at the same hierarchy\n * level within the JS object and every section is identified by an arbitrary ID.\n */\nclass SwcParser {\n  constructor() {\n    this._morphology = null\n    this._rawMorphology = null\n  }\n\n\n  /**\n   * Parses a SWC string. This SWC string is simply the text content of an SWC file.\n   * This method does not return any reult (use one of the getters for that)\n   * @param {String} swcStr - the string that comes from the SWC file\n   */\n  parse(swcStr) {\n    this._morphology = null\n    this._rawMorphology = null\n    const rawPoints = SwcParser.extractPoints(swcStr)\n    const treeNodeCollection = new TreeNodeCollection(rawPoints)\n    this._morphology = treeNodeCollection.getMorphology()\n    this._rawMorphology = treeNodeCollection.getRawMorphology()\n  }\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology() {\n    return this._rawMorphology\n  }\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n  /**\n   * @private\n   * build an Array of points from the SWC string.\n   * Each element of the array is itself an Array representing a point and it's metadata.\n   * A single point is an Array of form:\n   *   [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   * @param {String} swcStr - the string from the SWC file\n   * @return {Array} all the points\n   */\n  static extractPoints(swcStr) {\n    // remove header/comments from SWC\n    let result = swcStr.replace(/\\s*#.*?$/mg, '')\n    // remove empty lines and empty last line\n    result = result.trim().replace(/^\\s*$/mg, '')\n\n    // store the data in memory-efficient typed arrays\n    const lines = result.split('\\n')\n    const swcPoints = []\n\n    for (let i = 0; i < lines.length; i += 1) {\n      const row = lines[i].replace(/^\\s+/m, '').replace(/\\s+$/m, '').split(/[\\s,]+/)\n      if (row.length >= 7) {\n        // allow for sloppy SWC that contains integers written as floats\n        swcPoints[i] = [\n          Math.round(parseFloat(row[0])),\n          Math.round(parseFloat(row[1])),\n          parseFloat(row[2]),\n          parseFloat(row[3]),\n          parseFloat(row[4]),\n          parseFloat(row[5]),\n          Math.round(parseFloat(row[6])),\n        ]\n      }\n    }\n\n    return swcPoints\n  }\n}\n\nexport default SwcParser\n","import SwcParser from './SwcParser'\n\nexport default ({\n  SwcParser,\n})\n"],"names":["SWC_TYPES"],"mappings":"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"}