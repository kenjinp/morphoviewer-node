!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.swcmorphologyparser=e()}(this,function(){"use strict";const t={0:"undefined",1:"soma",2:"axon",3:"basal_dendrite",4:"apical_dendrite",5:"custom"},e={undefined:0,soma:1,axon:2,basal_dendrite:3,apical_dendrite:4,custom:5};class s{constructor(t=null){this._id=null,this._parent=null,this._children=[],this._typename=null,this._typevalue=null,this._points=null,this._radiuses=null,this._morphology=t}setId(t){this._id=t}getId(){return this._id}setTypename(t){t in e?(this._typename=t,this._typevalue=e[t]):console.warn(`The typename must be one of ${Object.key(e).join(" ")}`)}getTypename(){return this._typename}setTypeValue(t){this._typevalue=t}getTypevalue(){return this._typevalue}addPoint(t,e,s,i=1){this._points.push([t,e,s]),this._radiuses.push(i)}getPoints(){return this._points}getRadiuses(){return this._radiuses}initWithRawSection(s){return this._id=s.id,this._points=s.points.map(t=>t.position),this._radiuses=s.points.map(t=>t.radius),(s.typename||s.typevalue)&&(this._typename=s.typename||t[s.typevalue],this._typevalue=s.typevalue||e[s.typename]),this._id}setParent(t){return t&&t.getId()!==this._id?(this._parent=t,!0):(console.warn("A section cannot be the parent of itself."),!1)}getParent(){return this._parent}addChild(t){return t.getId()!==this._id?(this.hasChild(t)?console.warn("The given section is already one of the child to this one."):this._children.push(t),!0):(console.warn("A section cannot be the child of itself."),!1)}hasChild(t){if(!this._children)return!1;const e=t.getId();for(let t=0;t<this._children.length;t+=1)if(this._children[t].getId()===e)return!0;return!1}getSize(){let t=0;for(let e=0;e<this._points.length-1;e+=1){const s=this._points[e],i=this._points[e+1],n=s[0]-i[0],o=s[1]-i[1],r=s[2]-i[2];t+=Math.sqrt(n*n+o*o+r*r)}return t}getMorphology(){return this._morphology}getChildren(){return this._children}}class i{constructor(){this._id=null,this._typename="soma",this._typevalue=1,this._points=[],this._radius=null}setId(t){this._id=t}getId(){return this._id}addPoint(t,e,s){this._points.push([t,e,s])}getPoints(){return this._points}setRadius(t){this._radius=t}getRadius(){return this._radius}getCenter(){const t=this._points.length;if(1===t)return this._points[0].slice();if(t>1){const e=[0,0,0];for(let s=0;s<t;s+=1)e[0]+=this._points[s][0],e[1]+=this._points[s][1],e[2]+=this._points[s][2];return e[0]/=t,e[1]/=t,e[2]/=t,e}return null}initWithRawSection(t){return t?(this._id=t.id,this._points=t.points.map(t=>t.position),this._radius=t.radius,this._id):(console.warn("Cannot init the Soma instance, no soma data provided in raw morphology."),null)}}var n={Morphology:class{constructor(){this._id=null,this._sections={},this._soma=null,this._specialSections={}}setId(t){this._id=t}getId(){return this._id}buildFromRawMorphology(t){t.soma&&(this._soma=new i,this._soma.initWithRawSection(t.soma));for(let e=0;e<t.sections.length;e+=1){const i=new s(this),n=i.initWithRawSection(t.sections[e]);this._sections[n]=i}for(let e=0;e<t.sections.length;e+=1){const s=t.sections[e],i=this._sections[s.id];if(null!==s.parent){const t=this._sections[s.parent];i.setParent(t)}const n=s.children.map(t=>this._sections[t]);for(let t=0;t<n.length;t+=1)i.addChild(n[t])}}getNumberOfSections(){return Object.keys(this._sections)}getSection(t){return t in this._sections?this._sections[t]:null}getArrayOfSections(){return Object.values(this._sections)}getSoma(){return this._soma}getOrphanSections(t=!1){return this._findSpecialSection("orphans",t=>!t.getParent(),t),this._specialSections.orphans}_findSpecialSection(t,e,s=!1){if(t in this._specialSections||(this._specialSections[t]=null),s||!this._specialSections[t]){this._specialSections[t]=[];const s=Object.values(this._sections);for(let i=0;i<s.length;i+=1)e(s[i])&&this._specialSections[t].push(s[i])}return this._specialSections[t]}}};var o={SWC_TYPES:{UNDEFINED:0,SOMA:1,AXON:2,BASAL_DENDRITE:3,APICAL_DENDRITE:4,CUSTOM:5}};class r{constructor(t,e,s,i,n,o){this._id=t,this._type=e,this._position=[s,i,n],this._radius=o,this._parent=null,this._children=[],this._hasSomaChildren=!1}getId(){return this._id}getType(){return this._type}isSoma(){return this._type===o.SOMA}getRadius(){return this._radius}getPosition(){return this._position}setParent(t){this._parent=t,t._addChild(this)}getParent(){return this._parent}_addChild(t){this.doesAlreadyHaveChild(t)||(this._children.push(t),this._hasSomaChildren=t.isSoma()||this._hasSomaChildren)}getChildren(){return this._children}getNonSomaChildren(){if(!this._hasSomaChildren)return this._children;const t=[];for(let e=0;e<this._children.length;e+=0)this._children[e].isSoma()||t.push(this._children[e]);return t}doesAlreadyHaveChild(t){for(let e=0;e<this._children.length;e+=1)if(this._children[e].getId()===t.getId())return!0;return!1}dive(t){t.push(this);const e=this.getNonSomaChildren();return 1!==e.length?e:e[0].getType()===this._type?e[0].dive(t):(console.warn(`Non-soma node (id:${this._id} type:${this._type}) has a single child of different type (id:${e[0].getId()} type:${this.getType()})`),[])}}class h{constructor(t){this._nodes={},this._rawSoma=null,this._rawSections=null,this._rawMorphology=null,this._morphology=null,this._initCollection(t),this._buildSections(),this._buildMorphologyObjects()}getRawMorphology(){return this._rawMorphology}getMorphology(){return this._morphology}_initCollection(t){const e=[];for(let s=0;s<t.length;s+=1){const i=new r(t[s][0],t[s][1],t[s][2],t[s][3],t[s][4],t[s][5]);this._nodes[t[s][0]]=i,t[s][1]===o.SOMA&&e.push(i);const n=t[s][6];if(-1===n)continue;const h=this._nodes[n];i.setParent(h)}e.length&&(this._rawSoma={id:0,type:"soma",radius:Math.max(...e.map(t=>t.getRadius())),points:e.map(t=>({position:t.getPosition()}))})}_buildSections(){let t=0;const e=[];let s=null,i=[];const n=Object.keys(this._nodes);for(let t=0;t<n.length;t+=1){const e=n[t],o=this._nodes[e].getNonSomaChildren();if(o.length>0){s=this._nodes[e],i=o;break}}if(!s)return void console.warn("No valid section here");const o=[];for(let t=0;t<i.length;t+=1)o.push({node:i[t],parentSectionId:null});function r(s,i){const n=[];s.getParent()&&n.push(s.getParent());const r=s.dive(n),h=n.map(t=>({position:t.getPosition(),radius:t.getRadius()}));null===i&&h.length&&(h[0].radius=0);const l={typevalue:s.getType(),typename:null,points:h,id:t,children:[],parent:i};i&&e[i].children.push(t);for(let e=0;e<r.length;e+=1)o.push({node:r[e],parentSectionId:t});return t+=1,l}for(;o.length;){const t=o.pop(),s=r(t.node,t.parentSectionId);e.push(s),e[s.id]=s}e.length&&(this._rawSections=e)}_buildMorphologyObjects(){this._rawSections||console.warn("This morphology has no section to export"),this._rawSoma||console.warn("This morphology has no soma to show"),this._rawSections||this._rawSoma?(this._rawMorphology={soma:this._rawSoma,sections:this._rawSections},this._morphology=new n.Morphology,this._morphology.buildFromRawMorphology(this._rawMorphology)):console.warn("No valid morphology data.")}}class l{constructor(){this._morphology=null,this._rawMorphology=null}parse(t){this._morphology=null,this._rawMorphology=null;const e=l.extractPoints(t),s=new h(e);this._morphology=s.getMorphology(),this._rawMorphology=s.getRawMorphology()}getRawMorphology(){return this._rawMorphology}getMorphology(){return this._morphology}static extractPoints(t){let e=t.replace(/\s*#.*?$/gm,"");const s=(e=e.trim().replace(/^\s*$/gm,"")).split("\n"),i=[];for(let t=0;t<s.length;t+=1){const e=s[t].replace(/^\s+/m,"").replace(/\s+$/m,"").split(/[\s,]+/);e.length>=7&&(i[t]=[Math.round(parseFloat(e[0])),Math.round(parseFloat(e[1])),parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4]),parseFloat(e[5]),Math.round(parseFloat(e[6]))])}return i}}return{SwcParser:l}});
