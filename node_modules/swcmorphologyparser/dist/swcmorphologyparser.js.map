{"version":3,"file":"swcmorphologyparser.js","sources":["../node_modules/morphologycorejs/es/morphologycorejs.js","../src/Constants.js","../src/TreeNode.js","../src/TreeNodeCollection.js","../src/SwcParser.js","../src/index.js"],"sourcesContent":["/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/*\nStandardized swc files (www.neuromorpho.org)\n0 - undefined\n1 - soma\n2 - axon\n3 - (basal) dendrite\n4 - apical dendrite\n5+ - custom\n*/\nconst TYPEVALUE_2_TYPENAME = {\n  0: 'undefined',\n  1: 'soma',\n  2: 'axon',\n  3: 'basal_dendrite',\n  4: 'apical_dendrite',\n  5: 'custom',\n};\n\nconst TYPENAME_2_TYPEVALUE = {\n  undefined: 0,\n  soma: 1,\n  axon: 2,\n  basal_dendrite: 3,\n  apical_dendrite: 4,\n  custom: 5,\n};\n\n\n/**\n * A section is a list of 3D points and some metadata. A section can have one parent\n * and multiple children when the dendrite or axone divide into mutliple dendrites\n * and axons.\n * A section instance can be built from scratch of it can be built using a raw object,\n * usually from a JSON description.\n */\nclass Section {\n  /**\n   * To construct a section, we need a reference to the morphology instance that\n   * 'hosts' them. This may seem a bit a bit counter intuitive to have a reference\n   * in that direction but it can be very convenient, when knowing a section, to\n   * know to which morphology it belongs (i.e. raycasting a section)\n   * @param {Morphology} morphology - the Morphology instance that host _this_ section\n   */\n  constructor(morphology = null) {\n    this._id = null;\n    this._parent = null;\n    this._children = [];\n    this._typename = null;\n    this._typevalue = null;\n    this._points = null;\n    this._radiuses = null;\n    this._morphology = morphology;\n  }\n\n\n  /**\n   * Defines the id of this seciton.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id;\n  }\n\n\n  /**\n   * Get the id of _this_ section\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Define the typename, like in the SWC spec. Must be one of:\n   *  - \"undefined\"\n   *  - \"soma\" (even though this one should be used to build a Soma instance)\n   *  - \"axon\"\n   *  - \"basal_dendrite\"\n   *  - \"apical_dendrite\"\n   *  - \"custom\"\n   * Not that this method automaically sets the typevalue accordingly.\n   * For more info, go to http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n   * @param {String} tn - the typename\n   */\n  setTypename(tn) {\n    if (tn in TYPENAME_2_TYPEVALUE) {\n      this._typename = tn;\n      this._typevalue = TYPENAME_2_TYPEVALUE[tn];\n    } else {\n      console.warn(`The typename must be one of ${Object.key(TYPENAME_2_TYPEVALUE).join(' ')}`);\n    }\n  }\n\n\n  /**\n   * Get the typename as a String\n   * @return {String}\n   */\n  getTypename() {\n    return this._typename\n  }\n\n\n  /**\n   * Defnies the typevalue, which is the integer that goes in pair with the type name.\n   * According to SWC spec. Must be one of:\n   * - 0, for undefined\n   * - 1, for soma (even though this one should be used to build a Soma instance)\n   * - 2, for axon\n   * - 3, for basal dendrite\n   * - 4, for apical dendrite\n   * - 5, for custom\n   * Note that defining the type value will automatically set the type name accordingly.\n   * @param {Number} tv - the type value\n   */\n  setTypeValue(tv) {\n    this._typevalue = tv;\n  }\n\n\n  /**\n   * Get the type value\n   * @return {Number}\n   */\n  getTypevalue() {\n    return this._typevalue\n  }\n\n\n  /**\n   * Add a point to _this_ current section\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   * @param {Number} r - the radius at the point to add. (default: 1)\n   */\n  addPoint(x, y, z, r = 1) {\n    this._points.push([x, y, z]);\n    this._radiuses.push(r);\n  }\n\n\n  /**\n   * Get all the points of _this_ section as an array\n   * @return {Array} each element are of form [x: Number, y: Number, y: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Get all the radiuses of the point in _this_ section\n   * @return {Array}\n   */\n  getRadiuses() {\n    return this._radiuses\n  }\n\n\n  /**\n   * Build a section using a raw section object.\n   * @param {Object} rawSection - usually comes from a JSON file\n   */\n  initWithRawSection(rawSection) {\n    this._id = rawSection.id;\n\n    this._points = rawSection.points.map(p => p.position);\n    this._radiuses = rawSection.points.map(p => p.radius);\n\n    // in some cases, we have only the typename or the typevalue, in this case we perform  a lookup\n    if (rawSection.typename || rawSection.typevalue) {\n      this._typename = rawSection.typename || TYPEVALUE_2_TYPENAME[rawSection.typevalue];\n      this._typevalue = rawSection.typevalue || TYPENAME_2_TYPEVALUE[rawSection.typename];\n    }\n\n    return this._id\n  }\n\n\n  /**\n   * Define the parent section of _this_ section, as an object reference.\n   * The only verification perfomed by this method is that a section is not added\n   * as its own parent.\n   * @param {Section} section - the section that is the parent of this one\n   * @return {Boolean} true if parent was successfully defined, false if not.\n   */\n  setParent(section) {\n    if (section && section.getId() !== this._id) {\n      this._parent = section;\n      return true\n    }\n\n    console.warn('A section cannot be the parent of itself.');\n    return false\n  }\n\n\n  /**\n   * Get the parent section of _this_ section\n   * @return {Section} the parent\n   */\n  getParent() {\n    return this._parent\n  }\n\n\n  /**\n   * Make a given section the child of _this_ one.\n   * Two verifications are perfomed before: ids must be diferent so that we are\n   * not allowing a section to be the child of itself, and that _this_ section\n   * does not already have the given section as a children (=> avoid doublons)\n   * @param {Section} section - The section to add as a child\n   * @return {Boolean} true if successfully added (of if already has the given child),\n   * false if the candidate cannot be a child\n   */\n  addChild(section) {\n    if (section.getId() !== this._id) {\n      if (this.hasChild(section)) {\n        console.warn('The given section is already one of the child to this one.');\n      } else {\n        this._children.push(section);\n      }\n      return true\n    }\n    console.warn('A section cannot be the child of itself.');\n    return false\n  }\n\n\n  /**\n   * Checks if a given section is already one of the children of _this_ section\n   * @param {Section} section - a section to test\n   * @return {Boolean} true if the given section is already a child of _this_ section, false if not.\n   */\n  hasChild(section) {\n    if (!this._children) return false\n\n    const candidateId = section.getId();\n\n    for (let i = 0; i < this._children.length; i += 1) {\n      if (this._children[i].getId() === candidateId) return true\n    }\n    return false\n  }\n\n\n  /**\n   * Get the size of _this_ section\n   * @return {Number}\n   */\n  getSize() {\n    let sum = 0;\n    for (let i = 0; i < this._points.length - 1; i += 1) {\n      const p1 = this._points[i];\n      const p2 = this._points[i + 1];\n      const dx = p1[0] - p2[0];\n      const dy = p1[1] - p2[1];\n      const dz = p1[2] - p2[2];\n      sum += Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n\n    return sum\n  }\n\n\n  /**\n   * Get the morphology object that contains this section\n   * @return {Morphology}\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n\n  /**\n   * Get all the children as an Array\n   * @return {Array}\n   */\n  getChildren() {\n    return this._children\n  }\n}\n\n/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/**\n * The soma is the cell body of a neurone and thus is sort of a simplified version\n * of a Section, in term of datastructure.\n * A soma can be made of a single point (then it's just a center point) or of several,\n * then it's a more accurate description of a soma. When described with several points,\n * the representation is usually as a 2D polygon (even though it's in a 3D space)\n */\nclass Soma {\n  constructor() {\n    this._id = null;\n    this._typename = 'soma';\n    this._typevalue = 1;\n    this._points = [];\n    this._radius = null;\n  }\n\n  /**\n   * Defines the id of this soma.\n   * Note: should probably not be used after `initWithRawSection` because then\n   * sections already have ids and chance to messup the id game are pretty high.\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id;\n  }\n\n\n  /**\n   * Get the id of _this_ soma\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Add a point to the soma description\n   * @param {Number} x - the x coordinate of the point to add\n   * @param {Number} y - the y coordinate of the point to add\n   * @param {Number} z - the z coordinate of the point to add\n   */\n  addPoint(x, y, z) {\n    this._points.push([x, y, z]);\n  }\n\n\n  /**\n   * Get all the points of the soma\n   * @return {Array} each element of the array if of form [x: Number, y: Number, z: Number]\n   */\n  getPoints() {\n    return this._points\n  }\n\n\n  /**\n   * Define the radius of the soma\n   * @param {Number} r - the radius\n   */\n  setRadius(r) {\n    this._radius = r;\n  }\n\n\n  /**\n   * Get the radius of the soma.\n   * @return {Number}\n   */\n  getRadius() {\n    return this._radius\n  }\n\n\n  /**\n   * Return the center of the soma.\n   * If the soma is made of a single point and a radius, this method returns the\n   * single point. If the soma is made of several points, this method returns the\n   * average.\n   * @return {Array|null} coordinate of the center as [x: Number, y: Number, z: Number]\n   */\n  getCenter() {\n    const nbPoints = this._points.length;\n\n    if (nbPoints === 1) {\n      return this._points[0].slice()\n    }\n\n    if (nbPoints > 1) {\n      const average = [0, 0, 0];\n      for (let i = 0; i < nbPoints; i += 1) {\n        average[0] += this._points[i][0];\n        average[1] += this._points[i][1];\n        average[2] += this._points[i][2];\n      }\n      average[0] /= nbPoints;\n      average[1] /= nbPoints;\n      average[2] /= nbPoints;\n      return average\n    }\n    return null\n  }\n\n\n  /**\n   * Build a soma using a raw soma object.\n   * @param {Object} rawSoma - usually comes from a JSON file\n   */\n  initWithRawSection(rawSoma) {\n    if (!rawSoma) {\n      console.warn('Cannot init the Soma instance, no soma data provided in raw morphology.');\n      return null\n    }\n\n    this._id = rawSoma.id;\n    this._points = rawSoma.points.map(p => p.position);\n    this._radius = rawSoma.radius;\n\n    return this._id\n  }\n}\n\n/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  Apache License 2.0\n* Lab      Blue Brain Project, EPFL\n*/\n\n\n/**\n * A morphology is the data representation of a neurone's anatomy. It is composed\n * of one soma (cell body) and sections. Sections can be axons, dendrites, etc.\n * A Morphology instance can be built from scratch (though it can be a bit tedious)\n * but will generally be built using a JSON description.\n */\nclass Morphology {\n  constructor() {\n    this._id = null;\n    this._sections = {};\n    this._soma = null;\n\n    // these are catgories of sections that we may need. Look at `getOrphanSections`\n    // and `_findSpecialSection`\n    this._specialSections = {};\n  }\n\n\n  /**\n   * Set the ID of _this_ morphology\n   * @param {String|Number} id - the id\n   */\n  setId(id) {\n    this._id = id;\n  }\n\n\n  /**\n   * Get the ID of _this_ morphology\n   * @return {String|Number}\n   */\n  getId() {\n    return this._id\n  }\n\n\n  /**\n   * Build a morphology from a raw dataset, that usually comes from a JSON file.\n   * Note that some files do not provide any data about the soma. In this case, the Soma\n   * instance remains `null`\n   * @param {Object} rawMorphology - a flat tree description of a morphology\n   */\n  buildFromRawMorphology(rawMorphology) {\n    // Sometimes, we have no data about the soma\n    if (rawMorphology.soma) {\n      this._soma = new Soma();\n      this._soma.initWithRawSection(rawMorphology.soma);\n    }\n\n    // Build the Section instances.\n    // This first step does not define parents nor children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const s = new Section(this);\n      const sId = s.initWithRawSection(rawMorphology.sections[i]);\n      this._sections[sId] = s;\n    }\n\n    // Now we define parent and children\n    for (let i = 0; i < rawMorphology.sections.length; i += 1) {\n      const currentRawSection = rawMorphology.sections[i];\n      const currentSection = this._sections[currentRawSection.id];\n\n      // adding a parent if there is one\n      // can be 0 but cannot be null (in JS, 0 and null are diff)\n      if (currentRawSection.parent !== null) {\n        const parent = this._sections[currentRawSection.parent];\n        currentSection.setParent(parent);\n      }\n\n      const children = currentRawSection.children.map(c => this._sections[c]);\n      for (let c = 0; c < children.length; c += 1) {\n        currentSection.addChild(children[c]);\n      }\n    }\n  }\n\n\n  /**\n   * Retrieve the total number of section in this morphology\n   * @return {Number}\n   */\n  getNumberOfSections() {\n    return Object.keys(this._sections)\n  }\n\n\n  /**\n   * Get a section, given its id\n   * @param {String|Number} id - the id of a section\n   * @return {Section|null} the requested section or null if the id is invalid\n   */\n  getSection(id) {\n    if (id in this._sections) {\n      return this._sections[id]\n    }\n    return null\n  }\n\n\n  /**\n   * Get all the sections of _this_ morphology as an array, because sometimes it's\n   * more convenient for iterating.\n   * @return {Array} array of Section instances\n   */\n  getArrayOfSections() {\n    return Object.values(this._sections)\n  }\n\n\n  /**\n   * Get the soma Object\n   * @return {Soma}\n   */\n  getSoma() {\n    return this._soma\n  }\n\n\n  /**\n   * Get all the section with no parent (_parent = null)\n   * Those are directly tied to the soma\n   * @param {Boolean} force - if true, the fetching among the sections will be done again\n   * @return {Array} array of Sections\n   */\n  getOrphanSections(force = false) {\n    const speciality = 'orphans';\n\n    // extract, if not done before\n    this._findSpecialSection(\n      'orphans',\n      s => !s.getParent(),\n      force,\n    );\n\n    return this._specialSections[speciality]\n  }\n\n\n  /**\n   * @private\n   * Helper function to build a subset of Sections based on the selections perfomed by `selector`\n   * @param {String} specialityName - name of the spaciality\n   * @param {Function} selector - function that takes a Section and returns a boolean.\n   * if true is return, a section will be selected\n   * @param {Boolean} force - if true: rebuild the list, if false:\n   * just return the list previously build\n   */\n  _findSpecialSection(specialityName, selector, force = false) {\n    if (!(specialityName in this._specialSections)) {\n      this._specialSections[specialityName] = null;\n    }\n\n    if (force || !this._specialSections[specialityName]) {\n      this._specialSections[specialityName] = [];\n      const allSections = Object.values(this._sections);\n      for (let i = 0; i < allSections.length; i += 1) {\n        if (selector(allSections[i])) {\n          this._specialSections[specialityName].push(allSections[i]);\n        }\n      }\n    }\n    return this._specialSections[specialityName]\n  }\n}\n\nvar index = ({\n  Morphology,\n});\n\n\n// export default Morphology\n\nexport default index;\n//# sourceMappingURL=morphologycorejs.js.map\n","/*\n * Defines the SWC standard types as in http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html\n */\nconst SWC_TYPES = {\n  UNDEFINED: 0,\n  SOMA: 1,\n  AXON: 2,\n  BASAL_DENDRITE: 3,\n  APICAL_DENDRITE: 4,\n  CUSTOM: 5,\n}\n\nexport default ({\n  SWC_TYPES,\n})\n","import SWC_TYPES from './Constants'\n\n/**\n * A TreeNode instance represent a point from the SWC file. It has a 3D coordinate,\n * an ID, a type, a radius, a reference to a parent (which is also a TreeNode\n * instance) and a list of children (also TreeNode instances).\n *\n * **Ressources**\n * - [SWC Spec](http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html)\n */\nclass TreeNode {\n  /**\n   * @param {Number} id - the id of the point\n   * @param {Number} type - type of structure this point comes from (cf. SWC spec)\n   * @param {Number} x - x component of the 3D coordinates\n   * @param {Number} y - y component of the 3D coordinates\n   * @param {Number} z - z component of the 3D coordinates\n   * @param {Number} r - radius at this given point\n   */\n  constructor(id, type, x, y, z, r) {\n    this._id = id\n    this._type = type\n    this._position = [x, y, z]\n    this._radius = r\n\n    this._parent = null\n    this._children = []\n\n    this._hasSomaChildren = false\n  }\n\n  /**\n   * Get the ID of _this_ node\n   * @return {Number}\n   */\n  getId() {\n    return this._id\n  }\n\n  /**\n   * Get the type as a number (according to the SWC spec)\n   * @return {Number}\n   */\n  getType() {\n    return this._type\n  }\n\n  /**\n   * @return {Boolean} true if this node is a soma, false if not\n   */\n  isSoma() {\n    return (this._type === SWC_TYPES.SOMA)\n  }\n\n  /**\n   * Get teh radius of _this_ node\n   * @return {Number}\n   */\n  getRadius() {\n    return this._radius\n  }\n\n  /**\n   * Get the 3D coordinates of this node\n   */\n  getPosition() {\n    return this._position\n  }\n\n  /**\n   * Define the parent of _this_ node\n   * @param {TreeNode} parent - the parent node\n   */\n  setParent(pNode) {\n    this._parent = pNode\n    pNode._addChild(this)\n  }\n\n  /**\n   * Get the parent node of _this_ one\n   * @return {TreeNode}\n   */\n  getParent() {\n    return this._parent\n  }\n\n  /**\n   * @private\n   * Add a child to _this_ node\n   * @param {TreeNode} cNode - a node to add as a child of _this_\n   */\n  _addChild(cNode) {\n    if (!this.doesAlreadyHaveChild(cNode)) {\n      this._children.push(cNode)\n\n      this._hasSomaChildren = cNode.isSoma() || this._hasSomaChildren\n    }\n  }\n\n  /**\n   * Get all the chidren\n   * @return {Array} array of TreeNode instances\n   */\n  getChildren() {\n    return this._children\n  }\n\n  /**\n   * Get all the children that are not soma points.\n   * @return {Array} array of TreeNode instances\n   */\n  getNonSomaChildren() {\n    if (!this._hasSomaChildren) {\n      return this._children\n    }\n\n    const nonSomaChildren = []\n\n    for (let i = 0; i < this._children.length; i += 0) {\n      if (!this._children[i].isSoma()) {\n        nonSomaChildren.push(this._children[i])\n      }\n    }\n    return nonSomaChildren\n  }\n\n  /**\n   * Check is _this_ node already has the given child amond its list of children\n   * @param {TreeNode} cNode - some node to test, most likely a potential child\n   * @return {Boolean} true if this child is already present, false if not\n   */\n  doesAlreadyHaveChild(cNode) {\n    for (let i = 0; i < this._children.length; i += 1) {\n      if (this._children[i].getId() === cNode.getId()) { return true }\n    }\n    return false\n  }\n\n  /**\n   * Dive into the TreeNode connection by following the children. Builds a list\n   * all along. Stops when a node has no more children (end of branch) or when a\n   * node has two children or more because it means it's a forking point.\n   * What is returned in the end is an array that can be empty (if end of branch)\n   * or with two or more TreeNode instance being the forking direction\n   * @param {Array} nodeList - contains the previous TreeNode (parent, grand parents, etc.)\n   * this array is only pushed to, nothing is taken or read from it.\n   * @return {Array} of TreeNodes that are forking direction.\n   */\n  dive(nodeList) {\n    // adding the current node on the list\n    nodeList.push(this)\n\n    const children = this.getNonSomaChildren()\n\n    // this current node is in the middle of a sections, we go on...\n    if (children.length === 1) {\n      if (children[0].getType() === this._type) {\n        return children[0].dive(nodeList)\n      }\n      console.warn(`Non-soma node (id:${this._id} type:${this._type}) has a single child of different type (id:${children[0].getId()} type:${this.getType()})`)\n\n\n    // this is or a ending point (no children) or a forking point (2 children or more).\n    // In both case, this the end of a sections\n    } else {\n      return children\n    }\n\n    return []\n  }\n}\n\nexport default TreeNode\n","import morphologycorejs from 'morphologycorejs'\nimport TreeNode from './TreeNode'\nimport SWC_TYPES from './Constants'\n\n/**\n * A TreeNodeCollection instance builds all the TreeNode instances from the raw\n * points list from the SWC file. As a second step, it builds the parent/children\n * relations between the nodes and as a third step, define a list of sections.\n */\nclass TreeNodeCollection {\n  /**\n   * @param {Array} points - every points of the array is itself an Array of form:\n   * [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   */\n  constructor(points) {\n    this._nodes = {}\n    this._rawSoma = null\n    this._rawSections = null\n    this._rawMorphology = null\n    this._morphology = null\n    this._initCollection(points)\n    this._buildSections()\n    this._buildMorphologyObjects()\n  }\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology() {\n    return this._rawMorphology\n  }\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n  /**\n   * @private\n   * Makes the list of nodes\n   */\n  _initCollection(points) {\n    const somaNodes = []\n\n    for (let i = 0; i < points.length; i += 1) {\n      const aNode = new TreeNode(\n        points[i][0], // id\n        points[i][1], // type\n        points[i][2], // x\n        points[i][3], // y\n        points[i][4], // z\n        points[i][5], // radius\n      )\n\n      this._nodes[points[i][0]] = aNode\n\n      // The soma nodes: in addition to put them in the regular collection,\n      // we also put them in a small collection we keep on the side\n      if (points[i][1] === SWC_TYPES.SOMA) {\n        somaNodes.push(aNode)\n      }\n\n      // In the SWC, a node/point seems to be always described after its parent,\n      // so we can makes the parent/children links in the same loop\n      const parentId = points[i][6]\n\n      // the first point of the soma has no parent\n      if (parentId === -1) { continue }\n\n      const theParentNode = this._nodes[parentId]\n      aNode.setParent(theParentNode)\n    }\n\n    // build the soma if we have some soma points\n    if (somaNodes.length) {\n      this._rawSoma = {\n        id: 0, // just to have the same format as the NeuroM converter\n        type: 'soma',\n        // the radius are usually all the same, but just in case, we take the largest one\n        radius: Math.max(...somaNodes.map(n => n.getRadius())),\n        points: somaNodes.map(n => ({ position: n.getPosition() })),\n      }\n    }\n  }\n\n  /**\n   * @private\n   * Reconstruct all the section from the nodes, give them IDs and establish the\n   * parent/children relationship\n   */\n  _buildSections() {\n    let currentSectionId = 0\n    const sections = []\n\n    // find the first node that has non-soma children:\n    let firstValidNode = null\n    let firstValidChildren = []\n\n    const allNodeIds = Object.keys(this._nodes)\n    for (let i = 0; i < allNodeIds.length; i += 1) {\n      const nodeId = allNodeIds[i]\n      const childrenOfNode = this._nodes[nodeId].getNonSomaChildren()\n      if (childrenOfNode.length > 0) {\n        firstValidNode = this._nodes[nodeId]\n        firstValidChildren = childrenOfNode\n        break\n      }\n    }\n\n    if (!firstValidNode) {\n      console.warn('No valid section here')\n      return\n    }\n\n    const stack = []\n\n    // add all the children of the firstValidNode into the stack\n    for (let i = 0; i < firstValidChildren.length; i += 1) {\n      stack.push({\n        node: firstValidChildren[i],\n        parentSectionId: null,\n      })\n    }\n\n    function buildRawSection(startingNode, parentSectionId) {\n      // the nodeList is the list of node for the section we are building.\n      // Let's say it's just a simpler version of the future section object\n      const nodeList = []\n\n      // for each starting node, we actually have to start by adding its parent\n      // to start the branch from its very basis\n      if (startingNode.getParent()) {\n        nodeList.push(startingNode.getParent())\n      }\n\n      // nodeList.push(startingNode)\n      // let nextNodes = startingNode.getNonSomaChildren()[0].dive(nodeList)\n\n      const nextNodes = startingNode.dive(nodeList)\n\n      const points = nodeList.map(n => ({\n        position: n.getPosition(),\n        radius: n.getRadius(),\n      }))\n\n      // if the first point is a soma point, we dont keep the first radius\n      // because it's the radius of the soma\n      if (parentSectionId === null && points.length) {\n        points[0].radius = 0\n      }\n\n      // now nodeList is full of nodes\n      const section = {\n        typevalue: startingNode.getType(),\n        typename: null, //\n        points,\n        id: currentSectionId,\n        children: [],\n        parent: parentSectionId,\n      }\n\n      // adding this section as a child of its parent\n      // (this is made possible because the parents are always defined before their children)\n      if (parentSectionId) {\n        sections[parentSectionId].children.push(currentSectionId)\n      }\n\n      // adding the next nodes as new section starting points\n      for (let i = 0; i < nextNodes.length; i += 1) {\n        stack.push({\n          node: nextNodes[i],\n          parentSectionId: currentSectionId,\n        })\n      }\n\n      currentSectionId += 1\n      return section\n    }\n\n    // popping the stack\n    while (stack.length) {\n      const stackElem = stack.pop()\n      const section = buildRawSection(stackElem.node, stackElem.parentSectionId)\n      sections.push(section)\n      sections[section.id] = section\n    }\n\n    if (sections.length) {\n      this._rawSections = sections\n    }\n  }\n\n  /**\n   * @private\n   * Performs some verification and then assemble the raw morphology\n   */\n  _buildMorphologyObjects() {\n    // it's ok to not have any section\n    if (!this._rawSections) {\n      console.warn('This morphology has no section to export')\n    }\n\n    // it's ok to not have a soma\n    if (!this._rawSoma) {\n      console.warn('This morphology has no soma to show')\n    }\n\n    // but it's not ok to have nothing at all\n    if (!this._rawSections && !this._rawSoma) {\n      console.warn('No valid morphology data.')\n      return\n    }\n\n    this._rawMorphology = {\n      soma: this._rawSoma,\n      sections: this._rawSections,\n    }\n\n    this._morphology = new morphologycorejs.Morphology()\n    this._morphology.buildFromRawMorphology(this._rawMorphology)\n  }\n}\n\nexport default TreeNodeCollection\n","import TreeNodeCollection from './TreeNodeCollection'\n\n\n/**\n * An instance of SwcParser is made to parse SWC files with\n * [the given specification](http://www.neuronland.org/NLMorphologyConverter/MorphologyFormats/SWC/Spec.html).\n * The data output by this parser is a Javascript object representing a the tree\n * structure of the morphology. Each node of the tree is a section that contain a reference\n * to its parent section and references to its children sections.\n * The tree is given flat, meaning all the sections are at the same hierarchy\n * level within the JS object and every section is identified by an arbitrary ID.\n */\nclass SwcParser {\n  constructor() {\n    this._morphology = null\n    this._rawMorphology = null\n  }\n\n\n  /**\n   * Parses a SWC string. This SWC string is simply the text content of an SWC file.\n   * This method does not return any reult (use one of the getters for that)\n   * @param {String} swcStr - the string that comes from the SWC file\n   */\n  parse(swcStr) {\n    this._morphology = null\n    this._rawMorphology = null\n    const rawPoints = SwcParser.extractPoints(swcStr)\n    const treeNodeCollection = new TreeNodeCollection(rawPoints)\n    this._morphology = treeNodeCollection.getMorphology()\n    this._rawMorphology = treeNodeCollection.getRawMorphology()\n  }\n\n  /**\n   * Get the raw morphology flat tree\n   * @return {Object} the soma and all the sections at the same level.\n   * Still, all the info about parent/children are present\n   */\n  getRawMorphology() {\n    return this._rawMorphology\n  }\n\n  /**\n   * Get the morphology object, which is much easier to query than the raw morphology\n   * @return {morphologycorejs.Morphology}\n   *\n   */\n  getMorphology() {\n    return this._morphology\n  }\n\n  /**\n   * @private\n   * build an Array of points from the SWC string.\n   * Each element of the array is itself an Array representing a point and it's metadata.\n   * A single point is an Array of form:\n   *   [\n   *     pointId: Number,\n   *     pointType: Number,\n   *     x: Number,\n   *     y: Number,\n   *     z: Number,\n   *     radius: Number,\n   *     parentId: Number\n   *   ]\n   * @param {String} swcStr - the string from the SWC file\n   * @return {Array} all the points\n   */\n  static extractPoints(swcStr) {\n    // remove header/comments from SWC\n    let result = swcStr.replace(/\\s*#.*?$/mg, '')\n    // remove empty lines and empty last line\n    result = result.trim().replace(/^\\s*$/mg, '')\n\n    // store the data in memory-efficient typed arrays\n    const lines = result.split('\\n')\n    const swcPoints = []\n\n    for (let i = 0; i < lines.length; i += 1) {\n      const row = lines[i].replace(/^\\s+/m, '').replace(/\\s+$/m, '').split(/[\\s,]+/)\n      if (row.length >= 7) {\n        // allow for sloppy SWC that contains integers written as floats\n        swcPoints[i] = [\n          Math.round(parseFloat(row[0])),\n          Math.round(parseFloat(row[1])),\n          parseFloat(row[2]),\n          parseFloat(row[3]),\n          parseFloat(row[4]),\n          parseFloat(row[5]),\n          Math.round(parseFloat(row[6])),\n        ]\n      }\n    }\n\n    return swcPoints\n  }\n}\n\nexport default SwcParser\n","import SwcParser from './SwcParser'\n\nexport default ({\n  SwcParser,\n})\n"],"names":["SWC_TYPES","morphologycorejs"],"mappings":"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"}